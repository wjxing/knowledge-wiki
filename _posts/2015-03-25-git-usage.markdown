---
layout: post
title: "Git Usage"
date: 2015-03-25 9:03
category: Git
tags: git tools
---
{% include JB/setup %}

Git Usage

------

##$ git config --list

------

### add alias in ~/.gitconfig
    [alias]
        log-a = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cN - %cr)%Creset' --abbrev-commit --date=relative
        diff-a = diff --name-status

------

##$ git log --abbrev-commit
缩短的commit SHA-1 ID

------

##$ git diff
查看当前文件和暂存区域的差别（也就是修改之后还没有暂存起来的变化内容）

    $ git diff --staged(或--cache)

查看已经暂存起来的文件和上次提交快照之间的差异

------

##$ git ignore
使用glob模式匹配
匹配模式最后跟斜杠说明要忽略的是目录
要忽略指定模式以外的文件或目录，可以在模式前加惊叹号取反

------

##$ git commint -a -m ""
跳过暂存操作，即跳过git add步骤

------

##$ git rm -f
如果删除之前修改过并且已经放到暂存区的话，则必须要用强制删除选项-f

    $ git rm --cached

把文件从git仓库中删除，但仍然希望保留在当前工作目录中

    $ git rm log/\*.log //不让shell展开*，但效果同下面
    $ git rm log/*.log

删除log目录下的以.log结尾的文件

    $ git rm \*.log

递归删除目录下的以.log结尾的文件

------

##$ git log
-p 按补丁格式显示每个更新之间差异

--stat 显示每次更新文件修改统计信息

--shortstat 只显示--stat中最后的行数修改添加移除统计

--name-only 仅在提交信息后显示已修改的文件清单

--name-status 显示新增、修改、删除的文件清单

--abbrev-commit 仅显示SHA-1的前几个字符

--relative-date 使用较短的相对时间显示

--graph 显示ASCII图形表示的分支合并历史

    $ git log --merges branch ^other_branch // 显示branch包含的，但other_branch不包含的log

------

### 限制git log输出长度
--since=2,week（也可以是具体某天2012-12-30） / --until=

------

##$ git branch -v
查看各分支最后一次提交

    $ git branch --merged

查看已经merged到本分支的分支列表，可以删除列出来的分支，因为已经merged

    $ git branch --no-merged

查看还没有merged到本分支的分支列表，如果要删除这些分支，需要强制删除git branch -D

------

### 查看分支指向的SHA
    $ git rev-parse master

------

### 查看几个月内HEAD和分支引用的日志
    $ git reflog

每次分支顶端因为某些原因被修改时，git就会将信息保存在这个临时历史记录里面

    $ git show HEAD@{5}
    $ git show master@{yesterday}
    $ git show HEAD@{2.months.ago}

想要看类似于git log输出格式的引用日志信息，可以运行

    $ git log -g master

------

### HEAD的父提交
    $ git show HEAD^

HEAD的第二父提交

    $ git show HEAD^2

第一父提交是合并时所在分支,而第二父提交是所合并的分支

------

### 创建空branch，并上传到服务器
    $ git symbolic-ref HEAD refs/heads/newbranch
    # rm .git/index
    $ git clean -fdx
    [do work]
    $ git add your files
    $ git commit -m 'Initial commit'
    $ git push origin HEAD:refs/heads/master

------

### 提交范围
假设有以下提交历史

    A <--- B <--- E <--- F <--- master
           \
             <--- C <--- D <--- experiment

    $ git log master..experiment

会显示所有可从experiment分支中获得而不能从master分支中获得的提交，
也可以留空语法中的一边来让 Git 来假定它是 HEAD

Git允许你在引用前使用^字符或者--not指明你不希望提交被包含其中的分支，因此下面三个命令是等同的

    $ git log refA..refB
    $ git log ^refA refB
    $ git log refB --not refA

这样允许在查询中指定多于两个的引用，如果想查找所有从refA或refB包含的但是不被refC包含的提交，可以输入下面中的一个

    $ git log refA refB ^refC
    $ git log refA refB --not refC

------

### 三点
这个可以指定被两个引用中的一个包含但又不被两者同时包含的分支，
针对上面的例子，如果想查看master或者experiment中包含的但不是两者共有的引用，可以运行

    $ git log master...experiment
    F
    E
    D
    C

这种情形下，log命令的一个常用参数是`--left-right`，它会显示每个提交到底处于哪一侧的分支

    $ git log --left-right master...experiment
    < F
    < E
    > D
    > C

------

### 交互式暂存
    $ git add -i
Git就进入了一个交互式的shell模式

### 暂存补丁
在交互式的提示符下，输入5或者p（表示patch，补丁），Git会询问哪些文件希望部分暂存；
然后对于被选中文件的每一节，他会逐个显示文件的差异区块并询问你是否希望暂存他们

可以在命令行下通过`git add -p`或者`git add --patch`来启动同样的脚本

------

### 储藏（Stashing）
    $ git stash

要查看现有的储藏，可以使用

    $ git stash list

重新应用刚刚实施的储藏

    $ git stash apply

如果想应用更早的储藏，可以通过名字指定它，像这样：

    $ git stash apply stash@{2}

对文件的变更被重新应用，如果想让被暂存的文件重新被暂存

    $ git stash apply --index

apply选项只尝试应用储藏的工作--储藏的内容仍然在栈上。要移除它，可以运行

    $ git stash drop

加上希望移除的储藏的名字

也可以运行

    $ git stash pop

来重新应用储藏，同时立刻将其从堆栈中移走

### 取消储藏(Un-applying a Stash)
Git没有提供类似于`stash unapply`的命令，但是可以通过取消该储藏的补丁达到同样的效果

    $ git stash show -p stash@{0} | git apply -R

### 从储藏中创建分支
可以运行

    $ git stash branch

这会创建一个新的分支，检出储藏工作时的所处的提交，重新应用所做的工作，如果成功，将会丢弃储藏

------

### 重写历史
如果只想修改最近一次提交说明，这非常简单

    $ git commit --amend

如果完成提交后又想修改被提交的快照，通过修改文件然后对其运行`git add`或对一个已被记录的文件运行`git rm`，
随后的`git commit --amend`会获取当前的暂存区并将它作为新提交对应的快照

### 修改多个提交说明
依靠这个交互式的`rebase`工具，就可以停留在每一次提交后，如果想修改或改变说明、增加文件或任何其他事情。
可以通过给`git rebase`增加`-i`选项来以交互方式地运行`rebase`。必须通过告诉命令衍合到哪次提交，来指明需要重写的提交的回溯深度

例如，想修改最近三次的提交说明，或者其中任意一次

    $ git rebase -i HEAD~3

### 重排提交
也可以使用交互式的衍合来彻底重排或删除提交，只要修改`rebase`的脚本即可

### 压制(Squashing)提交
交互式的衍合工具还可以将一系列提交压制为单一提交

### 拆分提交
可以在`rebase -i`脚本中修改想拆分的提交前的指令为"edit"，可以用

    git reset HEAD^

对那次提交进行一次混合的重置，这将撤销那次提交并且将修改的文件撤回。
此时可以暂存并提交文件，直到拥有多次提交，结束后，运行

    git rebase --continue

------

### 核弹级选项: filter-branch
如果想用脚本的方式修改大量的提交，可以用`filter-branch`，这个会大面积地修改历史

比如想从所有提交中删除password.txt文件

    $ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD

`--tree-filter`选项会在每次检出项目时先执行指定的命令然后重新提交结果

一个比较好的办法是在一个测试分支上做这些然后在确定产物真的是所要的之后，
再`hard-reset`主分支。要在所有的分支上运行`filter-branch`的话，可以传递`--all`给命令

将一个子目录设置为新的根目录

    $ git filter-branch --subdirectory-filter new_root_folder HEAD

全局性地更换电子邮件地址

    $ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
            GIT_AUTHOR_NAME="Scott Chacon";
            GIT_AUTHOR_EMAIL="schacon@example.com";
            git commit-tree "$@";
        else
            git commit-tree "$@";
        fi' HEAD
这个会遍历并重写所有提交使之拥有新地址。
因为提交里包含了它们的父提交的`SHA-1`值，这个命令会修改历史中的所有提交，而不仅仅是包含了匹配的电子邮件地址的那些

------

### 文件标注
文件标注会显示文件中对每一行进行修改的最近一次提交。可以使用-L选项来限制输出范围，比如：

    $ git blame -L 12,22 simplegit.txt

开头有`^`提交的那些行，指的是那个提交是文件第一次被加入这个项目时存在的，自那以后未被修改过

如果在`git blame`后加上`-C`，Git会分析标注的文件然后尝试找出其中代码片段的原始出处，如果它是从其他地方拷贝过来的话

------

### 二分查找
`bisect`会在提交历史中进行二分查找来尽快地确定哪一次提交引入了错误

首先运行`git bisect start`启动，然后用`git bisect bad`来告诉系统当前的提交已经有问题了。
然后必须告诉`bisect`已知的最后一次正常状态是哪次提交，使用`git bisect good [good_commit]`。
假设这里是没有错误的，那么就通过`git bisect good`来告诉Git继续旅程，
现在在另外一个提交上了，在刚刚测试通过的和一个错误提交的中点处。
再次运行测试然后发现这次提交是错误的，因此通过git bisect bad来告诉Git

当完成之后，应该运行`git bisect reset`来重设HEAD到开始前的地方。
如果有一个脚本会在工程正常时返回0，错误时返回非0的话，可以完全自动地执行git bisect。
先列出已知的错误提交再列出已知的正确提交：

    $ git bisect start HEAD v1.0
    $ git bisect run test-error.sh

这样会自动地在每一个检出的提交里运行test-error.sh直到Git找出第一个破损的提交

------

### 客户端基本配置

    $ git config --global commit.template $HOME/.gitmessage.txt

如果把此项指定为系统上的一个文件，当提交的时候，Git会默认使用该文件定义的内容

    $ git config --global user.signingkey <gpg-key-id>

现在能够签署标签，从而不必每次运行`git tag`命令时定义密钥

如果想用项目库之外的文件来定义那些需被忽略的文件的话，
用`core.excludesfile`通知Git该文件所处的位置，文件内容和.gitignore类似

如果把`help.autocorrect`设置成1（启动自动修正），
那么在只有一个命令被模糊匹配到的情况下，Git会自动运行该命令


